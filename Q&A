Accessing a value in a dictionary using its key

my_dict = {"name": "Alice", "age": 25}
print(my_dict["name"])  # Output: Alice











split() turns a string into a list, using spaces by default

text = "I love Python"
words = text.split()
print(words)  # Output: ['I', 'love', 'Python']







abs() returns the absolute (positive) value of a number

x = -5
result = abs(x)
print(result)  # Output: 5









while loop minimum execution

count = 1
while count <= 3:       # ✅ Condition is true initially, so loop runs
    print("Run:", count)
    count += 1

# If the condition is false from the start, loop doesn't run at all:
count = 5
while count < 3:        # ❌ Condition is false, so nothing happens
    print("This won't print")










Using slice objects with tuples

a = (0, 1, 2, 3, 4)       # A tuple with 5 elements
b = slice(0, 2)           # Creates a slice object for indices 0 to 1 (2 is exclusive)
result = a[b]             # Applies the slice to the tuple

print(result)             # Output: (0, 1)
# Explanation: slice(0, 2) extracts elements from index 0 up to but not including 2









# ✅ Set makes use of: 🔑 **only keys** (no values)
# ✅ Dictionary makes use of: 🔑 **key-value pairs**

# Example of Set
my_set = {"apple", "banana", "cherry"}  # just values (internally acts like keys)
print(my_set)

# Example of Dictionary
my_dict = {"apple": 1, "banana": 2}  # keys with values
print(my_dict)









Data type of: a = [(1, 1), (2, 4), (3, 9)]

a = [(1,1), (2,4), (3,9)]

# ✅ Explanation:
# a → list
# Each item inside a → tuple
# So it's a: list of tuples

print(type(a))         # 👉 <class 'list'>
print(type(a[0]))      # 👉 <class 'tuple'>










# a = (1, 2, 3, 4)
# a[1:-1] gives a slice from index 1 to one before the last

a = (1, 2, 3, 4)
print(a[1:-1])  # 👉 Output: (2, 3)











# else with if: runs ONLY if condition is False
x = 5
if x > 10:
    print("Greater")
else:
    print("Not greater")  # 👉 runs because x is not > 10

# else with while: runs ONLY if loop finishes without break
i = 0
while i < 3:
    print(i)
    i += 1
else:
    print("Loop ended normally")  # 👉 runs because no break

# else with for: also runs if no break happens
for i in range(3):
    print(i)
else:
    print("For loop done")  # 👉 runs because no break







# 🔤 String 
text = "hello"           # stores sequence of characters

# 📦 Dictionary is for key-value, 
my_dict = {"a": 1}      

# List is for ordered items






my_list = [10, 20, 30]
x = my_list.pop(1)  # removes and returns item at index 1 → 20
print(x)            # Output: 20
print(my_list)      # Output: [10, 30]





def subtract_and_store(value):
    return store - value  # uses global 'store' but does NOT change it inside function

store = 10
store = subtract_and_store(3)  # 10 - 3 = 7, store updated to 7
store = subtract_and_store(4)  # 7 - 4 = 3, store updated to 3
print(store)  # prints 3





typr error and value error
TypeError: x 5  y = "5"    z = x + y
ValueError:  int("five")





add "Mango" priced at $2.99 to the fruit_prices dictionary?
fruit_prices["Mango"] = 2.99







my_tuple = (1, 2, 3)
sum_of_tuple = sum(my_tuple)
print(sum_of_tuple)
# 6









# Tuple, List, and String can use * to repeat
print((1, 2) * 2)     # (1, 2, 1, 2)
print([1, 2] * 2)     # [1, 2, 1, 2]
print("Hi" * 2)       # HiHi

# Dict and Set can't use *
# {"a":1} * 2 → ❌ TypeError
# {1,2} * 2   → ❌ TypeError










 Chart: List vs Tuple vs Dictionary in Python**

| Feature                | **List**                     | **Tuple**                | **Dictionary**                           |
| ---------------------- | ---------------------------- | ------------------------ | ---------------------------------------- |
| **Syntax**             | `[1, 2, 3]`                  | `(1, 2, 3)`              | `{"key": "value"}`                       |
| **Ordered?**           | ✅ Yes                        | ✅ Yes                    | ❌ No (Python 3.7+ keeps insertion order) |
| **Mutable?**           | ✅ Yes                        | ❌ No                     | ✅ Yes                                    |
| **Allows Duplicates?** | ✅ Yes                        | ✅ Yes                    | ❌ No (keys must be unique)               |
| **Indexing?**          | ✅ By integer                 | ✅ By integer             | ✅ By key                                 |
| **Use Case**           | General collection, editable | Fixed data, safe to pass | Key-value storage, fast lookup           |
| **Memory Efficient?**  | ❌ Less                       | ✅ More                   | ❌ Depends on usage                       |
| **Methods Example**    | `append()`, `pop()`          | `count()`, `index()`     | `get()`, `items()`, `pop()`, `update()`  |
| **Conversion**         | `tuple(list)`                | `list(tuple)`            | `dict.fromkeys()`                        |








print(0.1 + 0.2 == 0.3)  # output False








✅ Correct Syntax:

try:
    # risky code here
    pass
except (TypeError, ValueError, ZeroDivisionError):
    print("An error occurred!")







lst = [i for i in range(-1, -2)]
# You can’t go from -1 to -2 using a positive step.  So the range is empty.








foo = (1, 2, 3)
foo.index(0)
# ValueError: tuple.index(x): x not in tuple





using break keyword is not allowed outside loop 







lst = [[x for x in range(3)] for y in range(3)]

for r in range(3):
    for c in range(3):
        if lst[r][c] % 2 != 0:
            print("#")










a = 1
b = 0
a = a ^ b
b = a ^ b
a = a ^ b
print(a, b)








my_list = [x * x for x in range(5)]

def fun(lst):
    del lst[lst[2]]
    return lst

print(fun(my_list))
# output [0, 1, 4, 9]








x = float(input())
y = float(input())
print(y ** (1 / x))
# output 2.0 








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































v




































