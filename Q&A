Accessing a value in a dictionary using its key

my_dict = {"name": "Alice", "age": 25}
print(my_dict["name"])  # Output: Alice











split() turns a string into a list, using spaces by default

text = "I love Python"
words = text.split()
print(words)  # Output: ['I', 'love', 'Python']







abs() returns the absolute (positive) value of a number

x = -5
result = abs(x)
print(result)  # Output: 5









while loop minimum execution

count = 1
while count <= 3:       # ✅ Condition is true initially, so loop runs
    print("Run:", count)
    count += 1

# If the condition is false from the start, loop doesn't run at all:
count = 5
while count < 3:        # ❌ Condition is false, so nothing happens
    print("This won't print")










Using slice objects with tuples

a = (0, 1, 2, 3, 4)       # A tuple with 5 elements
b = slice(0, 2)           # Creates a slice object for indices 0 to 1 (2 is exclusive)
result = a[b]             # Applies the slice to the tuple

print(result)             # Output: (0, 1)
# Explanation: slice(0, 2) extracts elements from index 0 up to but not including 2









# ✅ Set makes use of: 🔑 **only keys** (no values)
# ✅ Dictionary makes use of: 🔑 **key-value pairs**

# Example of Set
my_set = {"apple", "banana", "cherry"}  # just values (internally acts like keys)
print(my_set)

# Example of Dictionary
my_dict = {"apple": 1, "banana": 2}  # keys with values
print(my_dict)









Data type of: a = [(1, 1), (2, 4), (3, 9)]

a = [(1,1), (2,4), (3,9)]

# ✅ Explanation:
# a → list
# Each item inside a → tuple
# So it's a: list of tuples

print(type(a))         # 👉 <class 'list'>
print(type(a[0]))      # 👉 <class 'tuple'>










# a = (1, 2, 3, 4)
# a[1:-1] gives a slice from index 1 to one before the last

a = (1, 2, 3, 4)
print(a[1:-1])  # 👉 Output: (2, 3)











# else with if: runs ONLY if condition is False
x = 5
if x > 10:
    print("Greater")
else:
    print("Not greater")  # 👉 runs because x is not > 10

# else with while: runs ONLY if loop finishes without break
i = 0
while i < 3:
    print(i)
    i += 1
else:
    print("Loop ended normally")  # 👉 runs because no break

# else with for: also runs if no break happens
for i in range(3):
    print(i)
else:
    print("For loop done")  # 👉 runs because no break







# 🔤 String 
text = "hello"           # stores sequence of characters

# 📦 Dictionary is for key-value, 
my_dict = {"a": 1}      

# List is for ordered items






my_list = [10, 20, 30]
x = my_list.pop(1)  # removes and returns item at index 1 → 20
print(x)            # Output: 20
print(my_list)      # Output: [10, 30]





def subtract_and_store(value):
    return store - value  # uses global 'store' but does NOT change it inside function

store = 10
store = subtract_and_store(3)  # 10 - 3 = 7, store updated to 7
store = subtract_and_store(4)  # 7 - 4 = 3, store updated to 3
print(store)  # prints 3





typr error and value error
TypeError: x 5  y = "5"    z = x + y
ValueError:  int("five")



a = 10
b = "5"
print(a / b)  # ❌ TypeError








add "Mango" priced at $2.99 to the fruit_prices dictionary?
fruit_prices["Mango"] = 2.99







my_tuple = (1, 2, 3)
sum_of_tuple = sum(my_tuple)
print(sum_of_tuple)
# 6









# Tuple, List, and String can use * to repeat
print((1, 2) * 2)     # (1, 2, 1, 2)
print([1, 2] * 2)     # [1, 2, 1, 2]
print("Hi" * 2)       # HiHi

# Dict and Set can't use *
# {"a":1} * 2 → ❌ TypeError
# {1,2} * 2   → ❌ TypeError










 Chart: List vs Tuple vs Dictionary in Python**

| Feature                | **List**                     | **Tuple**                | **Dictionary**                           |
| ---------------------- | ---------------------------- | ------------------------ | ---------------------------------------- |
| **Syntax**             | `[1, 2, 3]`                  | `(1, 2, 3)`              | `{"key": "value"}`                       |
| **Ordered?**           | ✅ Yes                        | ✅ Yes                    | ❌ No (Python 3.7+ keeps insertion order) |
| **Mutable?**           | ✅ Yes                        | ❌ No                     | ✅ Yes                                    |
| **Allows Duplicates?** | ✅ Yes                        | ✅ Yes                    | ❌ No (keys must be unique)               |
| **Indexing?**          | ✅ By integer                 | ✅ By integer             | ✅ By key                                 |
| **Use Case**           | General collection, editable | Fixed data, safe to pass | Key-value storage, fast lookup           |
| **Memory Efficient?**  | ❌ Less                       | ✅ More                   | ❌ Depends on usage                       |
| **Methods Example**    | `append()`, `pop()`          | `count()`, `index()`     | `get()`, `items()`, `pop()`, `update()`  |
| **Conversion**         | `tuple(list)`                | `list(tuple)`            | `dict.fromkeys()`                        |








print(0.1 + 0.2 == 0.3)  # output False








✅ Correct Syntax:

try:
    # risky code here
    pass
except (TypeError, ValueError, ZeroDivisionError):
    print("An error occurred!")







lst = [i for i in range(-1, -2)]
# You can’t go from -1 to -2 using a positive step.  So the range is empty.








foo = (1, 2, 3)
foo.index(0)
# ValueError: tuple.index(x): x not in tuple





using break keyword is not allowed outside loop 







lst = [[x for x in range(3)] for y in range(3)]

for r in range(3):
    for c in range(3):
        if lst[r][c] % 2 != 0:
            print("#")










a = 1
b = 0
a = a ^ b
b = a ^ b
a = a ^ b
print(a, b)








my_list = [x * x for x in range(5)]

def fun(lst):
    del lst[lst[2]]
    return lst

print(fun(my_list))
# output [0, 1, 4, 9]








x = float(input())
y = float(input())
print(y ** (1 / x))
# output 2.0 











# Lesson: Counting how many '#' will print based on odd numbers in a nested list

lst = [[x for x in range(3)] for y in range(3)]
# lst is a 3x3 matrix:
# [
#  [0, 1, 2],
#  [0, 1, 2],
#  [0, 1, 2]
# ]

count = 0
for r in range(3):        # rows 0 to 2
    for c in range(3):    # columns 0 to 2
        if lst[r][c] % 2 != 0:  # check if value is odd
            print("#")
            count += 1

# Total odd numbers (1 in each row) = 3
print("Total '#' printed:", count)
# Output:
# #
# #
# #
# Total '#' printed: 3
















d = {'a': 1, 'b': 2}

for k in d.keys():
    print(k)  # keys

for v in d.values():
    print(v)  # values

for k, v in d.items():
    print(k, v)  # keys and values









# List: access by index (integer)
lst = ['a', 'b', 'c']
print(lst[0])  # 'a'

# Dict: access by key (not index)
d = {'one': 1, 'two': 2}
print(d['one'])  # 1

# KeyError if key missing
# print(d[0])  # Error

# Use get() to avoid error
print(d.get('one'))  # 1
print(d.get(0))      # None










PYTHON KEYWORD
| Category                | Keywords                                                          |
| ----------------------- | ----------------------------------------------------------------- |
| **Control Flow**        | `if`, `else`, `elif`, `for`, `while`, `break`, `continue`, `pass` |
| **Boolean / Logic**     | `True`, `False`, `and`, `or`, `not`, `is`, `in`                   |
| **Functions & Classes** | `def`, `return`, `lambda`, `yield`, `class`                       |
| **Exception Handling**  | `try`, `except`, `finally`, `raise`, `assert`                     |
| **Modules & Imports**   | `import`, `from`, `as`, `global`, `nonlocal`                      |
| **Object Management**   | `del`, `with`                                                     |
| **Data & Structure**    | `None`                                                            |
| **Async Programming**   | `async`, `await`                                                  |







# Build dictionary from list with one-item tuples and print the first element of each tuple

dictionary = {}
my_list = ['a', 'b', 'c', 'd']

# Create dictionary keys from list except last item, values are one-item tuples
for i in range(len(my_list) - 1):
    dictionary[my_list[i]] = (my_list[i], )

# Loop over sorted keys and print the first element of each tuple value
for i in sorted(dictionary.keys()):
    k = dictionary[i]
    print(k[0])  # prints 'a', 'b', 'c'












# Slice in tuple is ok 
tup = (1, 2, 4, 8)
tup = tup[1:-1]
tup = tup[0]
print(tup)







def fun(x):
    if x % 2 == 0:
        return 1
    else:
        return

print(fun(fun(2)) + 1)







def any():
    print(var + 1, end='')

var = 1
any()
print(var)  # output 21

2 from inside the function
1 from the global variable printed outside the function










def fun(x):
    x += 1
    return x

x = 2
x = fun(x + 1)
print(x)   # output 4









def func_1(a):
    return a ** a

def func_2(a):
    return func_1(a) * func_1(a)

print(func_2(2))  # 16










dictionary = {'one': 'two', 'three': 'one', 'two': 'three'}

for key, value in dictionary.items():
    print(key + " + " + value)


# one + two
three + one
two + three











def f(x):
    if x == 0:
        return 0         
    return x + f(x - 1)  # Recursive call: add current x to sum of smaller numbers

print(f(4))              # Output: 10







You Can’t Use Reserved Keywords as Function Parameters




def greet(name):
    print("Hello", name)

greet("Sara")
print(name)  # ❌ ERROR!










pop([i]) → Removes and returns item
count(x) → Counts occurrences







d = {"a":1, "b":2}
print(d.get("a", 0))      # 1
print(list(d.items()))    # [('a',1), ('b',2)]
print(list(d.keys()))     # ['a', 'b']
print(list(d.values()))   # [1, 2]

d.update({"c":3})         
print(d)                 # {'a':1, 'b':2, 'c':3}

d.pop("b")               
print(d)                 # {'a':1, 'c':3}

d.popitem()              
print(d)                 # {'a':1}

d.clear()                
print(d)                 # {}











my_dict = {"A": 1, "B": 2}

# Access value
val = my_dict["A"]          # 1

# Add / Modify entry
my_dict["C"] = 3            # {'A':1, 'B':2, 'C':3}

# Delete entry
del my_dict["B"]            # {'A':1, 'C':3}

# Dictionary comprehension (square numbers 0 to 4)
squared = {x: x**2 for x in range(5)}  
# {0:0, 1:1, 2:4, 3:9, 4:16}




packing unpacking tuple:
a, b, c = my_tuple

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































v




































